/*
 * Copyright 2024 SimpleDaemons
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "simple-sftpd/vulnerability_scanner.hpp"
#include "simple-sftpd/logger.hpp"
#include "simple-sftpd/ftp_server_config.hpp"
#include <filesystem>

namespace simple_sftpd {

VulnerabilityScanner::VulnerabilityScanner(std::shared_ptr<Logger> logger)
    : logger_(logger) {
}

std::vector<VulnerabilityScanner::Vulnerability> VulnerabilityScanner::scanConfiguration(const std::string& config_file) {
    std::vector<Vulnerability> vulnerabilities;
    
    if (!std::filesystem::exists(config_file)) {
        Vulnerability vuln;
        vuln.type = "MISSING_CONFIG";
        vuln.severity = "MEDIUM";
        vuln.description = "Configuration file not found: " + config_file;
        vuln.recommendation = "Create a configuration file with appropriate security settings";
        vulnerabilities.push_back(vuln);
        return vulnerabilities;
    }
    
    // Check file permissions
    auto perms = std::filesystem::status(config_file).permissions();
    if ((perms & std::filesystem::perms::others_read) != std::filesystem::perms::none) {
        Vulnerability vuln;
        vuln.type = "INSECURE_PERMISSIONS";
        vuln.severity = "HIGH";
        vuln.description = "Configuration file is world-readable: " + config_file;
        vuln.recommendation = "Set file permissions to 600 (owner read/write only)";
        vulnerabilities.push_back(vuln);
    }
    
    // Load and check configuration
    auto config = std::make_shared<FTPServerConfig>();
    if (config->loadFromFile(config_file)) {
        // Check SSL configuration
        if (!config->security.ssl_cert_file.empty() && !config->security.ssl_key_file.empty()) {
            if (!std::filesystem::exists(config->security.ssl_cert_file)) {
                Vulnerability vuln;
                vuln.type = "MISSING_SSL_CERT";
                vuln.severity = "HIGH";
                vuln.description = "SSL certificate file not found: " + config->security.ssl_cert_file;
                vuln.recommendation = "Generate or install SSL certificate";
                vulnerabilities.push_back(vuln);
            }
        } else if (!config->security.require_ssl) {
            Vulnerability vuln;
            vuln.type = "SSL_NOT_REQUIRED";
            vuln.severity = "MEDIUM";
            vuln.description = "SSL/TLS is not required for connections";
            vuln.recommendation = "Enable require_ssl for production deployments";
            vulnerabilities.push_back(vuln);
        }
        
        // Check chroot configuration
        if (!config->security.chroot_enabled) {
            Vulnerability vuln;
            vuln.type = "CHROOT_DISABLED";
            vuln.severity = "MEDIUM";
            vuln.description = "Chroot is disabled";
            vuln.recommendation = "Enable chroot for directory restrictions";
            vulnerabilities.push_back(vuln);
        }
        
        // Check privilege dropping
        if (!config->security.drop_privileges) {
            Vulnerability vuln;
            vuln.type = "PRIVILEGES_NOT_DROPPED";
            vuln.severity = "HIGH";
            vuln.description = "Privilege dropping is disabled";
            vuln.recommendation = "Enable drop_privileges for security hardening";
            vulnerabilities.push_back(vuln);
        }
        
        // Check anonymous access
        if (config->security.allow_anonymous) {
            Vulnerability vuln;
            vuln.type = "ANONYMOUS_ACCESS_ENABLED";
            vuln.severity = "LOW";
            vuln.description = "Anonymous access is enabled";
            vuln.recommendation = "Disable anonymous access if not needed";
            vulnerabilities.push_back(vuln);
        }
    }
    
    return vulnerabilities;
}

std::vector<VulnerabilityScanner::Vulnerability> VulnerabilityScanner::scanSystem() {
    std::vector<Vulnerability> vulnerabilities;
    
    // Check for common security issues
    checkFilePermissions();
    checkSSLConfiguration();
    
    return vulnerabilities;
}

std::vector<VulnerabilityScanner::Vulnerability> VulnerabilityScanner::checkSecurityConfig() {
    return scanSystem();
}

void VulnerabilityScanner::checkWeakPasswords() {
    // Would check for weak passwords in user database
    // Implementation depends on user storage mechanism
}

void VulnerabilityScanner::checkOpenPorts() {
    // Would check for unnecessarily open ports
    // Implementation would use system tools
}

void VulnerabilityScanner::checkFilePermissions() {
    // Check critical file permissions
    std::vector<std::string> critical_files = {
        "/etc/simple-sftpd/simple-sftpd.conf",
        "/etc/simple-sftpd/ssl/server.key"
    };
    
    for (const auto& file : critical_files) {
        if (std::filesystem::exists(file)) {
            auto perms = std::filesystem::status(file).permissions();
            if ((perms & std::filesystem::perms::others_read) != std::filesystem::perms::none) {
                logger_->warn("Insecure file permissions detected: " + file);
            }
        }
    }
}

void VulnerabilityScanner::checkSSLConfiguration() {
    // Check SSL certificate validity and strength
    // Would verify certificate expiration, key strength, etc.
}

} // namespace simple_sftpd

